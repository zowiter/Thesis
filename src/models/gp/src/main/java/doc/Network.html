<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
    <!-- Generated by javadoc (build 1.5.0_01) on Mon Apr 24 01:27:23 GMT+06:00 2006 -->
    <TITLE>
        Network
    </TITLE>

    <META NAME="keywords" CONTENT="Network class">

    <LINK REL="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

    <SCRIPT type="text/javascript">
        function windowTitle()
        {
            parent.document.title = "Network";
        }
    </SCRIPT>
    <NOSCRIPT>
    </NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
    <TR>
        <TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
            <A NAME="navbar_top_firstrow"><!-- --></A>
            <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
                <TR ALIGN="center" VALIGN="top">
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="package-summary.html"><FONT CLASS="NavBarFont1">
                        <B>Package</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>
                        &nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="class-use/Network.html"><FONT
                            CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B>
                    </FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1">
                        <B>Deprecated</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="index-files/index-1.html"><FONT
                            CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="help-doc.html"><FONT CLASS="NavBarFont1">
                        <B>Help</B></FONT></A>&nbsp;</TD>
                </TR>
            </TABLE>
        </TD>
        <TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
        </EM>
        </TD>
    </TR>

    <TR>
        <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
            &nbsp;<A HREF="MeshSwitch.html" title="class in &lt;Unnamed&gt;"><B>PREV CLASS</B></A>&nbsp;
            &nbsp;<A HREF="NetworkManager.html" title="class in &lt;Unnamed&gt;"><B>NEXT CLASS</B></A></FONT></TD>
        <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
            <A HREF="index.html?Network.html" target="_top"><B>FRAMES</B></A> &nbsp;
            &nbsp;<A HREF="Network.html" target="_top"><B>NO FRAMES</B></A> &nbsp;
            &nbsp;
            <SCRIPT type="text/javascript">
                <!--
                if (window == top) {
                    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
                }
                //-->
            </SCRIPT>
            <NOSCRIPT>
                <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
            </NOSCRIPT>


        </FONT></TD>
    </TR>
    <TR>
        <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
            SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A
                HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
        <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
            DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A
                HREF="#method_detail">METHOD</A></FONT></TD>
    </TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
    Class Network</H2>
<PRE>
    java.lang.Object
    <IMG SRC="./resources/inherit.gif" ALT="extended by "><B>Network</B>
</PRE>
<HR>
<DL>
    <DT>
    <PRE>public class <B>Network</B><DT>extends java.lang.Object
</DL>
</PRE>

<P>
    Network is the object through which all the nodes (Resource blocks) and all
    the communication switches are connected to perform the desired goal into one
    unit. According to the input parameters the network is built up. Different
    types of network topologies can be created but for simulation at a time only
    one type of network is instantiated. Mesh, Torus, Butterfly Fat Tree and
    Extended Butterfly Fat Tree, Octal are among the different types of network.

    N.B. Extended Butterfly Fat Tree (an extension of the Butterfly Fat Tree) and
    Octal (an extension of the Octagon topology) are two architectures originally
    proposed by the researchers in Dept. of CSE, BUET)

<P>

<P>
<DL>
    <DT><B>Version:</B></DT>
    <DD>1.0</DD>
</DL>
<HR>

<P>
    <!-- =========== FIELD SUMMARY =========== -->

    <A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
        <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
            <B>Field Summary</B></FONT></TH>
    </TR>
    <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
            <CODE>private &nbsp;java.util.Vector</CODE></FONT></TD>
        <TD><CODE><B><A HREF="Network.html#nodeList">nodeList</A></B></CODE>

            <BR>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A vector type variable holding the reference of
            all the resource nodes of
            the network.
        </TD>
    </TR>
    <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
            <CODE>private &nbsp;java.util.Vector</CODE></FONT></TD>
        <TD><CODE><B><A HREF="Network.html#switchList">switchList</A></B></CODE>

            <BR>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A vector type variable holding the reference of
            all the communication
            switches of the network.
        </TD>
    </TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
        <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
            <B>Constructor Summary</B></FONT></TH>
    </TR>
    <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD><CODE><B><A HREF="Network.html#Network(int)">Network</A></B>(int&nbsp;networkType)</CODE>

            <BR>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor of the Network.
        </TD>
    </TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
    <TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
        <B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#createExFatTreeNetwork()">createExFatTreeNetwork</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiates all the nodes and Extended Butterfly
        Fat Tree switches of
        the extended fat tree network as well as assigns which node will be
        connected with which extended fat tree switch.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#createFatTreeNetwork()">createFatTreeNetwork</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiates all the nodes and Butterfly Fat Tree
        switches of the fat
        tree network as well as assigns which node will be connected with which
        fat tree switch.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#createMeshNetwork()">createMeshNetwork</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiates all the nodes and mesh switches of the
        mesh network as well
        as assigns which node will be connected with which mesh switch.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#createOctalNetwork()">createOctalNetwork</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instantiates all the nodes and mesh switches of the
        Octal network as well
        as assigns which node will be connected with which Octal switch.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;int</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#getStartOfLevel(int)">getStartOfLevel</A></B>(int&nbsp;level)</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoked by Network.setAdjacentFatSwitch() and
        Network.setAdjacentExFatSwitch() to find out the first parent switch
        exists in the upper level by using current switch’s level and index in
        level values.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#moveNodeTrafficFromInputBufferToNodeMsgCenter(int)">moveNodeTrafficFromInputBufferToNodeMsgCenter</A></B>(int&nbsp;nCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to transfer the incoming flits
        at the input buffer of
        resource node to the message center of that node.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#moveNodeTrafficFromNodeToSwitch(int)">moveNodeTrafficFromNodeToSwitch</A></B>(int&nbsp;nCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to transfer the outgoing flits
        at the output buffer
        of resource node to the input buffer of the parent switch of that node.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#moveSwitchTrafficFromInputBufferToOutputBuffer(int)">moveSwitchTrafficFromInputBufferToOutputBuffer</A></B>(int&nbsp;nCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to transfer the incoming flits
        at the input buffer of
        the switch to output buffer of that switch depending on the switching
        info vector.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#moveSwitchTrafficFromOutputBufferToInputBufferOfNodeSwitch(int)">moveSwitchTrafficFromOutputBufferToInputBufferOfNodeSwitch</A></B>(int&nbsp;nCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to transfer the outgoing flits
        at the output buffer
        of the switch to input buffer of the adjacent switches and/or resource
        nodes.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setAdjacentExFatSwitch()">setAdjacentExFatSwitch</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Completes the creation of extended butterfly fat
        tree network by setting
        the adjacency relationship between the switches of consecutive different
        levels and switches of current level.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setAdjacentFatSwitch()">setAdjacentFatSwitch</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method completes the creation of butterfly fat
        tree network by
        setting the adjacency relationship between the switches of consecutive
        different levels.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setAdjacentMeshSwitch()">setAdjacentMeshSwitch</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Completes the creation of mesh network by setting
        the adjacency
        relationship between the switches of consecutive different rows and
        columns.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setAdjacentOctalSwitch()">setAdjacentOctalSwitch</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Completes the creation of octal network by setting
        the adjacency
        relationship between the switches of the same unit and the switches of
        other units.The units are added in the network in row major order i.e.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>private &nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setAdjacentTorusSwitch()">setAdjacentTorusSwitch</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        This method completes the creation of torus network by setting the
        adjacency relationship between the switches of consecutive different
        levels.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#setInitalEvents()">setInitalEvents</A></B>()</CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is called by the controller of the
        simulator to set initial
        events required for starting the simulator.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#updateAfterCycleStatus(int)">updateAfterCycleStatus</A></B>(int&nbsp;curCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The method performs its duty by calling nodes’
        updateStatusAfterCycle(nCycle) and switches'
        updateStatusAfterCycle(nCycle) method for every simulation cycle.
    </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
    <TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
        <CODE>&nbsp;void</CODE></FONT></TD>
    <TD><CODE><B><A HREF="Network.html#updateSwitchTrafficPathRequest(int)">updateSwitchTrafficPathRequest</A></B>(int&nbsp;nCycle)
    </CODE>

        <BR>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
        <TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
    </TR>
    <TR BGCOLOR="white" CLASS="TableRowColor">
        <TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
    </TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
        <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
            <B>Field Detail</B></FONT></TH>
    </TR>
</TABLE>

<A NAME="nodeList"><!-- --></A>

<H3>
    nodeList</H3>
<PRE>
    private java.util.Vector <B>nodeList</B></PRE>
<DL>
    <DD>A vector type variable holding the reference of all the resource nodes of
        the network. This list is used for retrieving nodes’ reference to invoke
        methods directly from network.

    <P>
    <DL>
    </DL>
</DL>
<HR>

<A NAME="switchList"><!-- --></A>

<H3>
    switchList</H3>
<PRE>
    private java.util.Vector <B>switchList</B></PRE>
<DL>
    <DD>A vector type variable holding the reference of all the communication
        switches of the network. This list is used for retrieving switches’
        reference to invoke methods directly from network.

    <P>
    <DL>
    </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
        <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
            <B>Constructor Detail</B></FONT></TH>
    </TR>
</TABLE>

<A NAME="Network(int)"><!-- --></A>

<H3>
    Network</H3>
<PRE>
    public <B>Network</B>(int&nbsp;networkType)</PRE>
<DL>
    <DD>Constructor of the Network. In this version of the simulator, the type of
        the networks that have been implemented are Mesh, Torus, Butterfly Fat
        Tree, Extended Butterfly Fat Tree, and Octal. The constructor performs in
        the following fashion.
        <ul>
            <li>Creates nodeList and switchList vector object.</li>
            <li>Checks the type of the network to build.</li>
            <li>The network of specified type is created along with creation of
                adjacency relationship with other switches for all the switches.
            </li>
        </ul>

    <P>
    <DL>
        <DT><B>Parameters:</B>
        <DD><CODE>networkType</CODE> - An integer which determines which type of network the
            constructor will build.
            <DT><B>See Also:</B>
        <DD><A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>
            IConstants</CODE></A>
    </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
    <TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
        <TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
            <B>Method Detail</B></FONT></TH>
    </TR>
</TABLE>

<A NAME="createMeshNetwork()"><!-- --></A>

<H3>
    createMeshNetwork</H3>
<PRE>
    public void <B>createMeshNetwork</B>()</PRE>
<DL>
    <DD>Instantiates all the nodes and mesh switches of the mesh network as well
        as assigns which node will be connected with which mesh switch. The
        method performs in the following manner.

        <ul>
            <li>Determines how many adjacent nodes per switch.</li>
            <li>Determines the number of switches required in the network.</li>
            <li>Calculates required number of mesh rows and columns with a target of
                number of rows and columns being equal (if not possible then number of
                columns being the higher).
            </li>
            <li>Calculates the number of bits required to encode row number and
                column number of a switch to form the address of a switch.
            </li>
            <li>Instantiate all the switch by assigning them corresponding address
                generated from row and column.
            </li>
            <li>For every instantiated switch instantiate the required number of
                adjacent nodes.
            </li>
        </ul>

        <p>
            Assumptions:
            <li>This method considers a topology that has either m*n Mesh Switches.
                Here n = m or m+1.
            </li>
            <li>This method also works for the Torus network.</li>
            <li>The Number of IP Nodes and Switches adjusted according to the n * m
                switch architecture. Where, n = m or m+1, i.e. the architecture is
                adjusted to have a square shape.
            </li>
        </p>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="MeshSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>MeshSwitch</CODE></A>,
                <A HREF="NetworkManager.html" title="class in &lt;Unnamed&gt;"><CODE>NetworkManager</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setAdjacentMeshSwitch()"><!-- --></A>

<H3>
    setAdjacentMeshSwitch</H3>
<PRE>
    private void <B>setAdjacentMeshSwitch</B>()</PRE>
<DL>
    <DD>Completes the creation of mesh network by setting the adjacency
        relationship between the switches of consecutive different rows and
        columns. The switches are added in the network in row major order i.e.
        first the earlier rows are filled. The method works in the following
        steps.

        <ul>
            <li>For every switch determine its row and column index.</li>
            <li>Calculates minimum number of switches required in the network to
                have an adjacent switch in the bottom direction for this switch.
            </li>
            <li>Calculates minimum number of switches required in the network to
                have an adjacent switch in the right direction for this switch.
            </li>
            <li>If row index of this switch is greater than zero then this switch
                will have adjacent switch in top direction. If it has adjacent switch in
                top direction then that is found out (just one row earlier and same
                column) and corresponding adjacency field is updated for each switch. And
                then input/output link controllers for top direction are added.
            </li>
            <li>If row index of this switch is less than the maximum number of rows
                in the mesh network and the network has sufficient number of switches to
                have an adjacent switch in bottom direction then the switch in bottom
                direction is found out (just one row below and same column). The
                adjacency fields are updated for both these switches along with adding
                input/output link controller for bottom direction.
            </li>
            <li>In the similar way left and right adjacent switches are found out by
                using column index value of the switch and corresponding adjacency
                information are updates.
            </li>
        </ul>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="MeshSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>MeshSwitch</CODE></A>,
                <A HREF="InputLinkController.html" title="class in &lt;Unnamed&gt;"><CODE>InputLinkController</CODE></A>,
                <A HREF="OutputLinkController.html"
                   title="class in &lt;Unnamed&gt;"><CODE>OutputLinkController</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setAdjacentTorusSwitch()"><!-- --></A>

<H3>
    setAdjacentTorusSwitch</H3>
<PRE>
    private void <B>setAdjacentTorusSwitch</B>()</PRE>
<DL>
    <DD><p>
        This method completes the creation of torus network by setting the
        adjacency relationship between the switches of consecutive different
        levels. The method works in almost the same way as was described for mesh
        network except the circular relation.
    </p>

        <p>
            The switches in the top most and bottom most rows have adjacency relation
            in top and bottom directions respectively whereas in mesh network they
            had no adjacency relations. And in similar way leftmost and rightmost
            columns have adjacency relation in left and right directions respectively
            whereas in mesh network they had no adjacency relations.
        </p>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="MeshSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>MeshSwitch</CODE></A>,
                <A HREF="InputLinkController.html" title="class in &lt;Unnamed&gt;"><CODE>InputLinkController</CODE></A>,
                <A HREF="OutputLinkController.html"
                   title="class in &lt;Unnamed&gt;"><CODE>OutputLinkController</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="createFatTreeNetwork()"><!-- --></A>

<H3>
    createFatTreeNetwork</H3>
<PRE>
    public void <B>createFatTreeNetwork</B>()</PRE>
<DL>
    <DD>Instantiates all the nodes and Butterfly Fat Tree switches of the fat
        tree network as well as assigns which node will be connected with which
        fat tree switch. The method performs in the flowing manner.

        <ul>
            <li>Calculates the number of levels through which the network will be
                distributed.
            </li>
            <li>Calculates the number of bits required to identify each switch and
                nodes.
            </li>
            <li>Calculates number of fat tree switch will exist in level l.</li>
            <li>Instantiates corresponding number of fat tree switches for the level
                l.
            </li>
            <li>If that level is the lowest level of the network of fat tree switch
                then instantiate four nodes for every switch of that level.
            </li>
        </ul>

        <p>
            Assumptions:
            <li>This method also works for the ExtendedButterFly network.</li>
            <li>The Number of IP Nodes and Switches adjusted according to the a
                complete fat tree format.
            </li>
        </p>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="FatTreeSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>FatTreeSwitch</CODE>
            </A>,
                <A HREF="InputLinkController.html" title="class in &lt;Unnamed&gt;"><CODE>InputLinkController</CODE></A>,
                <A HREF="OutputLinkController.html"
                   title="class in &lt;Unnamed&gt;"><CODE>OutputLinkController</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setAdjacentFatSwitch()"><!-- --></A>

<H3>
    setAdjacentFatSwitch</H3>
<PRE>
    private void <B>setAdjacentFatSwitch</B>()</PRE>
<DL>
    <DD>This method completes the creation of butterfly fat tree network by
        setting the adjacency relationship between the switches of consecutive
        different levels. The method works in the following steps.

        <ul>
            <li>Calculates the number of levels through which the network is
                distributed.
            </li>
            <li>Calculates the number of switches that will exist in top most level
                of the network.
            </li>
            <li>For every switch other than top level switches
                <ul>
                    <li>Finds its level value and index value in that level.</li>
                    <li>Finds out the first parent switch exists in the upper level by using
                        current switch’s level and index in level values.
                    </li>
                    <li>Updates the parent child relationship between the found out parent
                        switch and current switch.
                    </li>
                    <li>Find out the second parent switch exists in the upper level by using
                        current switch’s level and index in level values.
                    </li>
                    <li>Updates the parent child relationship between the found out parent
                        switch and current switch.
                    </li>

                </ul>
            </li>
        </ul>

    <P>
    <DD>
        <DL>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="createOctalNetwork()"><!-- --></A>

<H3>
    createOctalNetwork</H3>
<PRE>
    public void <B>createOctalNetwork</B>()</PRE>
<DL>
    <DD>Instantiates all the nodes and mesh switches of the Octal network as well
        as assigns which node will be connected with which Octal switch. The
        switches are added grouped in a unit of 8 switches. These units in the
        network are then added in row major order i.e. first the earlier rows are
        filled. The method performs in the following manner.

        <ul>
            <li>Determines how many adjacent nodes per switch.</li>
            <li>Determines the number of switches required in the network.</li>
            <li>Determines the number of units required in the network.</li>
            <li>Calculates required number of unit rows and columns with a target of
                number of rows and columns being equal (if not possible then number of
                columns being the higher).
            </li>
            <li>Calculates the number of bits required to encode unit row number and
                column number of a unit to form the address of a unit.
            </li>
            <li>Computes the switch address from the unit address to which it
                belongs.
            </li>
            <li>Instantiate all the switch by assigning them the corresponding
                address.
            </li>
            <li>For every instantiated switch instantiate the required number of
                adjacent nodes.
            </li>
        </ul>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="OctalSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>OctalSwitch</CODE></A>,
                <A HREF="NetworkManager.html" title="class in &lt;Unnamed&gt;"><CODE>NetworkManager</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setAdjacentOctalSwitch()"><!-- --></A>

<H3>
    setAdjacentOctalSwitch</H3>
<PRE>
    private void <B>setAdjacentOctalSwitch</B>()</PRE>
<DL>
    <DD>Completes the creation of octal network by setting the adjacency
        relationship between the switches of the same unit and the switches of
        other units.The units are added in the network in row major order i.e.
        first the earlier rows are filled. The method works in the following
        steps.

    <ul>
        <li>For every unit determine its row and column index.</li>
        <li>Each switch in the network can have maximum 4 links with adjacent
            switches. 3 of those can used to connect to switches of the same unit
            (identified by, OCTAL_SWITCH_MID_1, RIGHT_NODE, LEFT_NODE).
            OCTAL_SWITCH_MID_2 is used to connect with a switch in a different unit.
            Although the name suggested by LEFT_NODE, RIGHT_NODE implies switches
            arranged according to clockwise or anticlockwise orientation, the
            relative address of the switchs to whitch the switch in question is
            connected by these two links are specified by the
            IConstatnts.ADJ_NODE[][]. The relative index of the switch to which this
            switch in question is connected via OCTAL_SWITCH_MID_1 is obtained from
            (7-this_switch_address_in_the_unit). The switch in adjacent unit to which
            the switch in question is connected via OCTAL_SWITCH_MID_2 is also can be
            obtained by similar process.
        </li>

        <li> For those switches, OCTAL_SWITCH_MID_2 is not possible, output link
            controller and input link controller are set to NULL.
        </li>

        <P>
        <DD>
            <DL>
                <DT><B>See Also:</B>
                <DD><A HREF="OctalSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>OctalSwitch</CODE>
                </A>,
                    <A HREF="InputLinkController.html" title="class in &lt;Unnamed&gt;"><CODE>InputLinkController</CODE>
                    </A>,
                    <A HREF="OutputLinkController.html"
                       title="class in &lt;Unnamed&gt;"><CODE>OutputLinkController</CODE></A>,
                    <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
            </DL>
        </DD>
</DL>
<HR>

<A NAME="createExFatTreeNetwork()"><!-- --></A>

<H3>
    createExFatTreeNetwork</H3>
<PRE>
    public void <B>createExFatTreeNetwork</B>()</PRE>
<DL>
    <DD>Instantiates all the nodes and Extended Butterfly Fat Tree switches of
        the extended fat tree network as well as assigns which node will be
        connected with which extended fat tree switch. The method performs in the
        flowing manner.

        <ul>
            <li>Calculates the number of levels through which the network will be
                distributed.
            </li>
            <li>Calculates the number of bits required to identify each switch and
                nodes.
            </li>
            <li>Calculates number of fat tree switch will exist in level l.</li>
            <li>Instantiates corresponding number of fat tree switches for the level
                l.
            </li>
            <li>If that level is the lowest level of the network of fat tree switch
                then instantiate four nodes for every switch of that level.
            </li>
        </ul>

    <p>
        The approach is similar to that of Fat Tree Network.

    <p>
        Assumptions:
        <li>This method also works for the ExtendedButterFly network.</li>
        <li>The Number of IP Nodes and Switches adjusted according to a complete
            fat tree format.
        </li>
    </p>

    <P>
    <DD>
        <DL>
            <DT><B>See Also:</B>
            <DD><A HREF="ExFatTreeSwitch.html" title="class in &lt;Unnamed&gt;"><CODE>
                ExFatTreeSwitch</CODE></A>,
                <A HREF="InputLinkController.html" title="class in &lt;Unnamed&gt;"><CODE>InputLinkController</CODE></A>,
                <A HREF="OutputLinkController.html"
                   title="class in &lt;Unnamed&gt;"><CODE>OutputLinkController</CODE></A>,
                <A HREF="IConstants.html" title="class in &lt;Unnamed&gt;"><CODE>IConstants</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setAdjacentExFatSwitch()"><!-- --></A>

<H3>
    setAdjacentExFatSwitch</H3>
<PRE>
    private void <B>setAdjacentExFatSwitch</B>()</PRE>
<DL>
    <DD>Completes the creation of extended butterfly fat tree network by setting
        the adjacency relationship between the switches of consecutive different
        levels and switches of current level. Switches of extended butterfly fat
        tree network have relationship among the switches of the same level
        depending on specific formula along with the child and parent
        relationship between the switches of lower and upper level switches. The
        method performs same works as was done for butterfly fat tree network
        along with some extra works. Those are described below.

        <ul>
            <li>Like butterfly fat tree finds out two parent of a switch and update
                the child parent relation among those.
            </li>
            <li>Calculates the left sibling index and right sibling index among the
                block in which the switches form local connections.
            </li>
            <li>Updates the left and right sibling relationship among those
                switches.
            </li>
        </ul>

    <P>
    <DD>
        <DL>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="getStartOfLevel(int)"><!-- --></A>

<H3>
    getStartOfLevel</H3>
<PRE>
    private int <B>getStartOfLevel</B>(int&nbsp;level)</PRE>
<DL>
    <DD>Invoked by Network.setAdjacentFatSwitch() and
        Network.setAdjacentExFatSwitch() to find out the first parent switch
        exists in the upper level by using current switch’s level and index in
        level values.

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>level</CODE> - Level in the Butterfly Fat Tree, Extended Butterfly Fat Tree
                topology
                <DT><B>Returns:</B>
            <DD>Index value in the switch list
                <DT><B>See Also:</B>
            <DD><A
                    HREF="Network.html#setAdjacentFatSwitch()"><CODE>setAdjacentFatSwitch()</CODE></A>,
                <A HREF="Network.html#setAdjacentExFatSwitch()"><CODE>setAdjacentExFatSwitch()</CODE></A>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="setInitalEvents()"><!-- --></A>

<H3>
    setInitalEvents</H3>
<PRE>
    public void <B>setInitalEvents</B>()</PRE>
<DL>
    <DD>This method is called by the controller of the simulator to set initial
        events required for starting the simulator. The method performs in the
        following steps.

    <ul>
        <li>For all resource nodes set next message generation timestamps</li>
        <li>Resets all the switches and switching info vector of the switches.</li>
        <li>Resets the statistical data calculator.</li>
        <ul>
            <P>
            <DD>
                <DL>
                </DL>
            </DD>
</DL>
<HR>

<A NAME="moveNodeTrafficFromNodeToSwitch(int)"><!-- --></A>

<H3>
    moveNodeTrafficFromNodeToSwitch</H3>
<PRE>
    public void <B>moveNodeTrafficFromNodeToSwitch</B>(int&nbsp;nCycle)</PRE>
<DL>
    <DD>This method is used to transfer the outgoing flits at the output buffer
        of resource node to the input buffer of the parent switch of that node.
        The method performs its duty by calling nodes’ updateOutput(nCycle)
        method for every simulation cycle.

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>nCycle</CODE> - Simulation cycle
        </DL>
    </DD>
</DL>
<HR>

<A NAME="updateSwitchTrafficPathRequest(int)"><!-- --></A>

<H3>
    updateSwitchTrafficPathRequest</H3>
<PRE>
    public void <B>updateSwitchTrafficPathRequest</B>(int&nbsp;nCycle)</PRE>
<DL>
    <DD>
        <DL>
        </DL>
    </DD>
</DL>
<HR>

<A NAME="moveSwitchTrafficFromInputBufferToOutputBuffer(int)"><!-- --></A>

<H3>
    moveSwitchTrafficFromInputBufferToOutputBuffer</H3>
<PRE>
    public void <B>moveSwitchTrafficFromInputBufferToOutputBuffer</B>(int&nbsp;nCycle)</PRE>
<DL>
    <DD>This method is used to transfer the incoming flits at the input buffer of
        the switch to output buffer of that switch depending on the switching
        info vector. The method performs its duty by calling switches’
        moveInputBufferToOutputBuffer(nCycle) method for every simulation cycle.

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>nCycle</CODE> - Simulation cycle
        </DL>
    </DD>
</DL>
<HR>

<A NAME="moveSwitchTrafficFromOutputBufferToInputBufferOfNodeSwitch(int)"><!-- --></A>

<H3>
    moveSwitchTrafficFromOutputBufferToInputBufferOfNodeSwitch</H3>
<PRE>
    public void <B>moveSwitchTrafficFromOutputBufferToInputBufferOfNodeSwitch</B>(int&nbsp;nCycle)</PRE>
<DL>
    <DD>This method is used to transfer the outgoing flits at the output buffer
        of the switch to input buffer of the adjacent switches and/or resource
        nodes. The method performs its assigned activities by calling the
        switches’ moveSwitchOutputBufferToInputBufferOfNodeSwitch(nCycle) method
        for every simulation cycle.

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>nCycle</CODE> - Simulation cycle
        </DL>
    </DD>
</DL>
<HR>

<A NAME="moveNodeTrafficFromInputBufferToNodeMsgCenter(int)"><!-- --></A>

<H3>
    moveNodeTrafficFromInputBufferToNodeMsgCenter</H3>
<PRE>
    public void <B>moveNodeTrafficFromInputBufferToNodeMsgCenter</B>(int&nbsp;nCycle)</PRE>
<DL>
    <DD>This method is used to transfer the incoming flits at the input buffer of
        resource node to the message center of that node. The method performs its
        duty by calling nodes’ forwardFlitToNodeMessageCenter(nCycle) method for
        every simulation cycle

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>nCycle</CODE> - Simulation cycle
        </DL>
    </DD>
</DL>
<HR>

<A NAME="updateAfterCycleStatus(int)"><!-- --></A>

<H3>
    updateAfterCycleStatus</H3>
<PRE>
    public void <B>updateAfterCycleStatus</B>(int&nbsp;curCycle)</PRE>
<DL>
    <DD>The method performs its duty by calling nodes’
        updateStatusAfterCycle(nCycle) and switches'
        updateStatusAfterCycle(nCycle) method for every simulation cycle.

    <P>
    <DD>
        <DL>
            <DT><B>Parameters:</B>
            <DD><CODE>curCycle</CODE> - Simulation cycle
        </DL>
    </DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
    <TR>
        <TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
            <A NAME="navbar_bottom_firstrow"><!-- --></A>
            <TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
                <TR ALIGN="center" VALIGN="top">
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="package-summary.html"><FONT CLASS="NavBarFont1">
                        <B>Package</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>
                        &nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="class-use/Network.html"><FONT
                            CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B>
                    </FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1">
                        <B>Deprecated</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="index-files/index-1.html"><FONT
                            CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
                    <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"><A HREF="help-doc.html"><FONT CLASS="NavBarFont1">
                        <B>Help</B></FONT></A>&nbsp;</TD>
                </TR>
            </TABLE>
        </TD>
        <TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
        </EM>
        </TD>
    </TR>

    <TR>
        <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
            &nbsp;<A HREF="MeshSwitch.html" title="class in &lt;Unnamed&gt;"><B>PREV CLASS</B></A>&nbsp;
            &nbsp;<A HREF="NetworkManager.html" title="class in &lt;Unnamed&gt;"><B>NEXT CLASS</B></A></FONT></TD>
        <TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
            <A HREF="index.html?Network.html" target="_top"><B>FRAMES</B></A> &nbsp;
            &nbsp;<A HREF="Network.html" target="_top"><B>NO FRAMES</B></A> &nbsp;
            &nbsp;
            <SCRIPT type="text/javascript">
                <!--
                if (window == top) {
                    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
                }
                //-->
            </SCRIPT>
            <NOSCRIPT>
                <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
            </NOSCRIPT>


        </FONT></TD>
    </TR>
    <TR>
        <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
            SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A
                HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
        <TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
            DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A
                HREF="#method_detail">METHOD</A></FONT></TD>
    </TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
